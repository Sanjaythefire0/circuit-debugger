<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VR Time-Travel Circuit Debugger</title>

<style>
body {
    margin:0;
    overflow:hidden;
    background:black;
    font-family:Arial;
}

#ui-container{
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    background:rgba(0,0,0,0.8);
    padding:15px;
    border-radius:10px;
    color:white;
}

button{
    background:#00ff00;
    border:none;
    padding:8px;
    font-weight:bold;
    cursor:pointer;
}

input{
    width:300px;
}
</style>

<script type="importmap">
{
"imports":{
"three":"https://unpkg.com/three@0.160.0/build/three.module.js",
"three/addons/":"https://unpkg.com/three@0.160.0/examples/jsm/"
}
}
</script>

</head>

<body>

<div id="ui-container">
<button id="play-btn">PLAY</button>
<br>
<input id="timeline" type="range" min="0" max="9" step="0.01" value="0">
<div id="time-display">T:0</div>
</div>

<script type="module">

import * as THREE from "three";
import {VRButton} from "three/addons/webxr/VRButton.js";
import {OrbitControls} from "three/addons/controls/OrbitControls.js";
import {XRControllerModelFactory} from "three/addons/webxr/XRControllerModelFactory.js";

////////////////////////////////////////////////////////////
// CONFIG
////////////////////////////////////////////////////////////

const CONFIG={
wireLength:10,
wireRadius:0.05,
pulseRadius:0.15
};

////////////////////////////////////////////////////////////
// STATE
////////////////////////////////////////////////////////////

let state={
time:0,
playing:false,
speed:2
};

////////////////////////////////////////////////////////////
// SCENE
////////////////////////////////////////////////////////////

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x050505);

////////////////////////////////////////////////////////////
// CAMERA + PLAYER RIG (CRITICAL FOR MOVEMENT)
////////////////////////////////////////////////////////////

const camera=new THREE.PerspectiveCamera(
70,
window.innerWidth/window.innerHeight,
0.1,
100
);

const player=new THREE.Group();
player.position.set(0,1.6,6);
player.add(camera);

scene.add(player);

////////////////////////////////////////////////////////////
// RENDERER
////////////////////////////////////////////////////////////

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.xr.enabled=true;

document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

////////////////////////////////////////////////////////////
// DESKTOP ORBIT CONTROL (optional)
////////////////////////////////////////////////////////////

new OrbitControls(camera,renderer.domElement);

////////////////////////////////////////////////////////////
// LIGHT
////////////////////////////////////////////////////////////

scene.add(new THREE.AmbientLight(0xffffff,2));

const dir=new THREE.DirectionalLight(0xffffff,3);
dir.position.set(5,10,5);
scene.add(dir);

////////////////////////////////////////////////////////////
// CIRCUIT
////////////////////////////////////////////////////////////

const circuit=new THREE.Group();
scene.add(circuit);

const wire=new THREE.Mesh(
new THREE.CylinderGeometry(CONFIG.wireRadius,CONFIG.wireRadius,CONFIG.wireLength,32),
new THREE.MeshStandardMaterial({color:0x004400})
);

wire.rotation.z=Math.PI/2;
circuit.add(wire);

////////////////////////////////////////////////////////////
// RESISTOR
////////////////////////////////////////////////////////////

function createResistor(x){

const g=new THREE.Group();

const body=new THREE.Mesh(
new THREE.CylinderGeometry(0.2,0.2,1,16),
new THREE.MeshStandardMaterial({color:0xd2b48c})
);

body.rotation.z=Math.PI/2;

const leadGeo=new THREE.CylinderGeometry(0.05,0.05,1);

const lead1=new THREE.Mesh(
leadGeo,
new THREE.MeshStandardMaterial({color:0xaaaaaa})
);

lead1.rotation.z=Math.PI/2;
lead1.position.x=-1;

const lead2=lead1.clone();
lead2.position.x=1;

g.add(body,lead1,lead2);

g.position.x=x;

return g;
}

circuit.add(createResistor(-4));
circuit.add(createResistor(2));

////////////////////////////////////////////////////////////
// LED
////////////////////////////////////////////////////////////

const ledMat=new THREE.MeshStandardMaterial({
color:0xff0000,
emissive:0xff0000,
emissiveIntensity:0.1
});

const led=new THREE.Mesh(
new THREE.SphereGeometry(0.3,32,32),
ledMat
);

led.position.x=4;

circuit.add(led);

////////////////////////////////////////////////////////////
// PULSE
////////////////////////////////////////////////////////////

const pulse=new THREE.Mesh(
new THREE.SphereGeometry(CONFIG.pulseRadius,32,32),
new THREE.MeshStandardMaterial({
color:0x00ffff,
emissive:0x00ffff,
emissiveIntensity:2
})
);

circuit.add(pulse);

////////////////////////////////////////////////////////////
// SIGNAL DATA
////////////////////////////////////////////////////////////

const signals=[
{time:0,pos:-4,fault:false},
{time:2,pos:-2,fault:false},
{time:4,pos:0,fault:false},
{time:5,pos:0,fault:true},
{time:7,pos:2,fault:true},
{time:9,pos:4,fault:false}
];

function getSignal(t){

let i=0;

while(i<signals.length-1 && signals[i+1].time<t)
i++;

const a=signals[i];
const b=signals[i+1];

if(!b)return a;

const alpha=(t-a.time)/(b.time-a.time);

return{
pos:a.pos+(b.pos-a.pos)*alpha,
fault:a.fault
};

}

////////////////////////////////////////////////////////////
// VR CONTROLLERS
////////////////////////////////////////////////////////////

const controller1=renderer.xr.getController(0);
const controller2=renderer.xr.getController(1);

scene.add(controller1,controller2);

const factory=new XRControllerModelFactory();

const grip1=renderer.xr.getControllerGrip(0);
grip1.add(factory.createControllerModel(grip1));
scene.add(grip1);

const grip2=renderer.xr.getControllerGrip(1);
grip2.add(factory.createControllerModel(grip2));
scene.add(grip2);

let leftPad=null;
let rightPad=null;

controller1.addEventListener("connected",e=>{
leftPad=e.data.gamepad;
});

controller2.addEventListener("connected",e=>{
rightPad=e.data.gamepad;
});

////////////////////////////////////////////////////////////
// DESKTOP MOVEMENT
////////////////////////////////////////////////////////////

window.addEventListener("keydown",e=>{

const speed=0.2;

if(e.key=="w")player.position.z-=speed;
if(e.key=="s")player.position.z+=speed;
if(e.key=="a")player.position.x-=speed;
if(e.key=="d")player.position.x+=speed;

});

////////////////////////////////////////////////////////////
// UI
////////////////////////////////////////////////////////////

const slider=document.getElementById("timeline");
const btn=document.getElementById("play-btn");
const label=document.getElementById("time-display");

slider.oninput=e=>state.time=parseFloat(e.target.value);

btn.onclick=()=>state.playing=!state.playing;

////////////////////////////////////////////////////////////
// LOOP
////////////////////////////////////////////////////////////

const clock=new THREE.Clock();

renderer.setAnimationLoop(()=>{

const dt=clock.getDelta();

if(state.playing){

state.time+=dt*state.speed;

if(state.time>9)state.time=0;

slider.value=state.time;

}

label.innerHTML="T:"+state.time.toFixed(2);

const sig=getSignal(state.time);

pulse.position.x=sig.pos;

wire.material.color.setHex(sig.fault?0xff0000:0x004400);

led.material.emissiveIntensity=sig.fault?2:0.1;

////////////////////////////////////////////////////////
// JOYSTICK MOVEMENT
////////////////////////////////////////////////////////

const moveSpeed=0.05;
const turnSpeed=0.03;

if(leftPad){

player.position.x+=leftPad.axes[2]*moveSpeed;
player.position.z+=leftPad.axes[3]*moveSpeed;

}

if(rightPad){

player.rotation.y-=rightPad.axes[2]*turnSpeed;

}

renderer.render(scene,camera);

});

////////////////////////////////////////////////////////////
// RESIZE
////////////////////////////////////////////////////////////

window.onresize=()=>{

camera.aspect=window.innerWidth/window.innerHeight;
camera.updateProjectionMatrix();

renderer.setSize(window.innerWidth,window.innerHeight);

};

</script>

</body>
</html>
